// Generated by CoffeeScript 1.6.3
(function() {
  var Shared, chkCmplType, csv, getOriginalType, getTeamByType, getType, getTypeAtTime, getpl, getplreal, loadTable, makeNames, makeOtherPrize, makePrize, path,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  csv = require('csv');

  path = require('path');

  Shared = {
    game: require('../client/code/shared/game.js')
  };

  makePrize = function(cb) {
    var dir, result;
    result = {};
    dir = path.normalize(__dirname + "/../prizedata");
    return csv().from.path("" + dir + "/win.csv").to.array(function(arr) {
      result.wincountprize = loadTable(arr);
      return csv().from.path("" + dir + "/lose.csv").to.array(function(arr) {
        result.losecountprize = loadTable(arr);
        makeOtherPrize(result);
        result.names = makeNames(result);
        return cb(result);
      });
    });
  };

  exports.makePrize = makePrize;

  loadTable = function(arr) {
    var i, jobname, name, normalflag, normaljobs, normals, ns, num, nums, obj, res, result, row, specials, _i, _j, _k, _len, _len1, _len2;
    result = {};
    nums = arr.shift();
    nums.shift();
    normals = [];
    specials = [];
    normaljobs = ["all", "Human", "Werewolf", "Diviner", "Psychic", "Madman", "Guard", "Couple", "Fox"];
    for (_i = 0, _len = nums.length; _i < _len; _i++) {
      num = nums[_i];
      res = num.match(/^(\d+)(?:\(\d+\))?$/);
      if (res) {
        normals.push(parseInt(res[1]));
        if (res[2] != null) {
          specials.push(parseInt(res[2]));
        } else {
          specials.push(parseInt(res[1]));
        }
      }
    }
    for (_j = 0, _len1 = arr.length; _j < _len1; _j++) {
      row = arr[_j];
      jobname = row.shift();
      normalflag = __indexOf.call(normaljobs, jobname) >= 0;
      result[jobname] = obj = {};
      for (i = _k = 0, _len2 = row.length; _k < _len2; i = ++_k) {
        name = row[i];
        if (name) {
          ns = name.split("\n");
          obj[normalflag ? normals[i] : specials[i]] = (ns.length > 1 ? ns : name);
        }
      }
    }
    return result;
  };

  makeNames = function(result) {
    var i, job, kind, n, name, names, num, obj, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
    names = {};
    _ref = result.wincountprize;
    for (job in _ref) {
      obj = _ref[job];
      for (num in obj) {
        name = obj[num];
        if (Array.isArray(name)) {
          for (i = _i = 0, _len = name.length; _i < _len; i = ++_i) {
            n = name[i];
            if (i === 0) {
              names["wincount_" + job + "_" + num] = n;
            } else {
              names["wincount_" + job + "_" + num + ":" + i] = n;
            }
          }
        } else {
          names["wincount_" + job + "_" + num] = name;
        }
      }
    }
    _ref1 = result.losecountprize;
    for (job in _ref1) {
      obj = _ref1[job];
      for (num in obj) {
        name = obj[num];
        if (Array.isArray(name)) {
          for (i = _j = 0, _len1 = name.length; _j < _len1; i = ++_j) {
            n = name[i];
            if (i === 0) {
              names["losecount_" + job + "_" + num] = n;
            } else {
              names["losecount_" + job + "_" + num + ":" + i] = n;
            }
          }
        } else {
          names["losecount_" + job + "_" + num] = name;
        }
      }
    }
    _ref2 = result.winteamcountprize;
    for (job in _ref2) {
      obj = _ref2[job];
      for (num in obj) {
        name = obj[num];
        if (Array.isArray(name)) {
          for (i = _k = 0, _len2 = name.length; _k < _len2; i = ++_k) {
            n = name[i];
            if (i === 0) {
              names["winteamcount_" + job + "_" + num] = n;
            } else {
              names["winteamcount_" + job + "_" + num + ":" + i] = n;
            }
          }
        } else {
          names["winteamcount_" + job + "_" + num] = name;
        }
      }
    }
    _ref3 = result.counterprize;
    for (kind in _ref3) {
      obj = _ref3[kind];
      _ref4 = obj.names;
      for (num in _ref4) {
        name = _ref4[num];
        names["" + kind + "_" + num] = name;
      }
    }
    _ref5 = result.ownprizesprize;
    for (kind in _ref5) {
      obj = _ref5[kind];
      _ref6 = obj.names;
      for (num in _ref6) {
        name = _ref6[num];
        names["" + kind + "_" + num] = name;
      }
    }
    return names;
  };

  makeOtherPrize = function(result) {
    result.winteamcountprize = {
      Human: {
        10: "白",
        50: "光"
      },
      Werewlf: {
        5: "偽り",
        10: "黒",
        50: "闇"
      }
    };
    result.loseteamcountprize = {};
    result.counterprize = {
      cursekill: {
        names: {
          1: "呪殺",
          5: "スナイパー",
          10: "天敵",
          15: "FOXHOUND",
          30: "ハンター",
          50: "奇跡"
        },
        func: function(game, pl) {
          return game.gamelogs.filter(function(x) {
            return x.id === pl.id && x.event === "cursekill";
          }).length;
        }
      },
      divineblack2: {
        names: {
          5: "千里眼",
          10: "心眼"
        },
        func: function(game, pl) {
          return game.gamelogs.filter(function(x) {
            var _ref;
            return x.id === pl.id && x.event === "divine" && (_ref = x.flag, __indexOf.call(Shared.game.blacks, _ref) >= 0);
          }).length;
        }
      },
      GJ: {
        names: {
          1: "GJ",
          5: "護衛",
          10: "鉄壁",
          15: "救世主",
          30: "ガーディアン"
        },
        func: function(game, pl) {
          return game.gamelogs.filter(function(x) {
            return x.id === pl.id && x.event === "GJ";
          }).length;
        }
      },
      lovers_wincount: {
        names: {
          1: "両想い",
          5: "いちゃいちゃ",
          10: "ラブラブ",
          15: "結婚",
          30: "比翼連理"
        },
        func: function(game, pl) {
          if (pl.winner && chkCmplType(pl, "Friend")) {
            return 1;
          } else {
            return 0;
          }
        }
      },
      lovers_losecount: {
        names: {
          1: "倦怠期",
          5: "浮気",
          10: "失恋",
          15: "離婚",
          30: "愛憎劇"
        },
        func: function(game, pl) {
          if (!pl.winner && chkCmplType(pl, "Friend")) {
            return 1;
          } else {
            return 0;
          }
        }
      },
      getkits_merchant: {
        names: {
          1: "受け取り",
          5: "取引先",
          10: "お得意様"
        },
        func: function(game, pl) {
          return game.gamelogs.filter(function(x) {
            return x.target === pl.id && x.event === "sendkit";
          }).length;
        }
      },
      sendkits_to_wolves: {
        names: {
          1: "誤送",
          10: "発注ミス"
        },
        func: function(game, pl) {
          return game.gamelogs.filter(function(x) {
            return x.id === pl.id && x.event === "sendkit" && getTeamByType(getTypeAtTime(game, x.target, x.day)) === "Werewolf";
          }).length;
        }
      },
      nocopy: {
        names: {
          1: "優柔不断",
          5: "null",
          10: "Undefined"
        },
        func: function(game, pl) {
          if (pl.type === "Copier") {
            return 1;
          } else {
            return 0;
          }
        }
      },
      day2hanged: {
        names: {
          1: "初日",
          5: "寡黙",
          10: "おはステ",
          15: "怪しい人",
          30: "壁"
        },
        func: function(game, pl) {
          return game.gamelogs.filter(function(x) {
            return x.id === pl.id && x.event === "found" && x.flag === "punish" && x.day === 2;
          }).length;
        }
      },
      allgamecount: {
        names: {
          1: "はじめて",
          5: "ビギナー",
          10: "ルーキー",
          15: "先輩",
          30: "経験者",
          50: "エリート",
          75: "エース",
          100: "キャプテン",
          150: "ベテラン",
          200: "インペリアル",
          300: "絶対",
          400: "カリスマ",
          500: "アルティメット",
          600: "進撃",
          750: "巨人",
          1000: "神話",
          1250: "永遠の旅人",
          1500: "冥王",
          2000: "レジェンド",
          10000: "もうやめよう"
        },
        func: function(game, pl) {
          return 1;
        }
      },
      aliveatlast: {
        names: {
          1: "生存",
          5: "生き残り",
          30: "最終兵器"
        },
        func: function(game, pl) {
          if (pl.dead) {
            return 0;
          } else {
            return 1;
          }
        }
      },
      revive: {
        names: {
          1: "蘇生",
          5: "黄泉がえり",
          10: "不死王",
          15: "アンデッド",
          30: "不死鳥"
        },
        func: function(game, pl) {
          return game.gamelogs.filter(function(x) {
            return x.id === pl.id && x.event === "revive";
          }).length;
        }
      },
      brainwashed: {
        names: {
          1: "教",
          5: "信",
          10: "徒"
        },
        func: function(game, pl) {
          return game.gamelogs.filter(function(x) {
            return x.target === pl.id && x.event === "brainwash";
          }).length;
        }
      }
    };
    return result.ownprizesprize = {
      prizecount: {
        names: {
          100: "天上天下",
          200: "神の子",
          300: "至高",
          400: "究極",
          500: "超越者"
        },
        func: function(prizes) {
          return prizes.length;
        }
      }
    };
  };

  getpl = function(game, userid) {
    return game.players.filter(function(x) {
      return x.id === userid;
    })[0];
  };

  getplreal = function(game, userid) {
    return game.players.filter(function(x) {
      return x.realid === userid;
    })[0];
  };

  chkCmplType = function(obj, cmpltype) {
    if (obj.isCmplType != null) {
      return obj.isCmplType(cmpltype);
    }
    if (obj.type === "Complex") {
      return obj.Complex_type === cmpltype || chkCmplType(obj.Complex_main, cmpltype);
    } else {
      return false;
    }
  };

  getType = function(pl) {
    if (pl.type === "Complex") {
      return getType(pl.Complex_main);
    } else {
      return pl.type;
    }
  };

  getOriginalType = function(game, userid) {
    return getTypeAtTime(game, userid, 0);
  };

  getTypeAtTime = function(game, userid, day) {
    var id, ls, pl, _ref, _ref1;
    id = (pl = getpl(game, userid)).id;
    ls = game.gamelogs.filter(function(x) {
      return x.event === "transform" && x.id === id && x.day > day;
    });
    return (_ref = (_ref1 = ls[0]) != null ? _ref1.type : void 0) != null ? _ref : getType(pl);
  };

  getTeamByType = function(type) {
    var arr, name, _ref;
    _ref = Shared.game.teams;
    for (name in _ref) {
      arr = _ref[name];
      if (__indexOf.call(arr, type) >= 0) {
        return name;
      }
    }
    return "";
  };

  exports.getOriginalType = getOriginalType;

  exports.getTeamByType = getTeamByType;

}).call(this);
